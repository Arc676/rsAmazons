/* automatically generated by rust-bindgen 0.59.2 */
// irrelevant fields removed from automatically generated file

#[allow(non_snake_case)]
#[allow(non_upper_case_globals)]
pub mod Amazons {
    use std::os::raw::c_int;
    use std::ptr;

    pub const SquareState_EMPTY: SquareState = 0;
    pub const SquareState_ARROW: SquareState = 1;
    pub const SquareState_WHITE: SquareState = 2;
    pub const SquareState_BLACK: SquareState = 4;
    pub const SquareState_SHARED: SquareState = 6;
    pub const SquareState_HAS_MOVES: SquareState = 8;
    pub const SquareState_UNDECIDED: SquareState = 14;

    #[doc = " Represents the possible states of a square on the board;"]
    #[doc = " additional states are used to represent regions of the board"]
    #[doc = " that are controlled by both players"]
    pub type SquareState = ::std::os::raw::c_uint;

    pub const CheckState_UNCHECKED: CheckState = 0;
    pub const CheckState_VISITED: CheckState = 1;
    pub const CheckState_ASSIGNED: CheckState = 2;

    #[doc = " Utility enum for representing the state of squares on the board"]
    #[doc = " during a flood fill used to determine who controls which region"]
    #[doc = " on the board"]
    pub type CheckState = ::std::os::raw::c_uint;

    #[doc = " Represents the board state of an ongoing game"]
    #[doc = " (number of pieces for each player, board size,"]
    #[doc = " board state, and regions controlled by each player)"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct BoardState {
        pub whitePieces: ::std::os::raw::c_int,
        pub blackPieces: ::std::os::raw::c_int,
        pub boardWidth: ::std::os::raw::c_int,
        pub boardHeight: ::std::os::raw::c_int,
        pub currentPlayer: SquareState,
        pub board: *mut SquareState,
        pub map: *mut SquareState,
    }

    impl Default for BoardState {
        fn default() -> Self {
            BoardState {
                whitePieces: 0,
                blackPieces: 0,
                boardWidth: 0,
                boardHeight: 0,
                currentPlayer: 0,
                board: ptr::null_mut(),
                map: ptr::null_mut(),
            }
        }
    }

    impl Drop for BoardState {
        fn drop(&mut self) {
            unsafe {
                boardstate_free(self);
            }
        }
    }

    #[test]
    fn bindgen_test_layout_BoardState() {
        assert_eq!(
            ::std::mem::size_of::<BoardState>(),
            40usize,
            concat!("Size of: ", stringify!(BoardState))
        );
        assert_eq!(
            ::std::mem::align_of::<BoardState>(),
            8usize,
            concat!("Alignment of ", stringify!(BoardState))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).whitePieces as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(whitePieces)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).blackPieces as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(blackPieces)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).boardWidth as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(boardWidth)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).boardHeight as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(boardHeight)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).currentPlayer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(currentPlayer)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).board as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(board)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<BoardState>())).map as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(BoardState),
                "::",
                stringify!(map)
            )
        );
    }

    #[doc = " Represents a square on the board"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Square {
        pub x: ::std::os::raw::c_int,
        pub y: ::std::os::raw::c_int,
    }

    impl Default for Square {
        fn default() -> Self {
            Square { x: 0, y: 0 }
        }
    }

    impl Square {
        pub fn new(x: u32, y: u32) -> Self {
            Square {
                x: x as c_int,
                y: y as c_int,
            }
        }

        pub fn destructure(&self) -> (u32, u32) {
            (self.x as u32, self.y as u32)
        }
    }

    #[test]
    fn bindgen_test_layout_Square() {
        assert_eq!(
            ::std::mem::size_of::<Square>(),
            8usize,
            concat!("Size of: ", stringify!(Square))
        );
        assert_eq!(
            ::std::mem::align_of::<Square>(),
            4usize,
            concat!("Alignment of ", stringify!(Square))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Square>())).x as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(Square), "::", stringify!(x))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Square>())).y as *const _ as usize },
            4usize,
            concat!("Offset of field: ", stringify!(Square), "::", stringify!(y))
        );
    }

    extern "C" {
        #[doc = " Swaps the given player to the other player"]
        #[doc = " @param player Player variable to swap"]
        pub fn swapPlayer(player: *mut SquareState);
    }

    extern "C" {
        #[doc = " Initializes a board with the given game settings"]
        #[doc = " @param board Board state to initialize"]
        #[doc = " @param wp Number of white/player 1 pieces"]
        #[doc = " @param bp Number of black/player 2 pieces"]
        #[doc = " @param bw Board width"]
        #[doc = " @param bh Board height"]
        #[doc = " @param whiteStart Array of Squares indicating starting locations for white player/player 1"]
        #[doc = " @Param blackStart Array of Squares indicating starting locations for black player/player 2"]
        pub fn boardstate_init(
            board: *mut BoardState,
            wp: ::std::os::raw::c_int,
            bp: ::std::os::raw::c_int,
            bw: ::std::os::raw::c_int,
            bh: ::std::os::raw::c_int,
            whiteStart: *mut Square,
            blackStart: *mut Square,
        );
    }

    extern "C" {
        #[doc = " Initializes a board with tournament standard configuration"]
        #[doc = " @param board Board state to initialize"]
        pub fn boardstate_standard(board: *mut BoardState);
    }

    extern "C" {
        #[doc = " Deallocates the memory occupied by a board"]
        #[doc = " @param board Board state"]
        pub fn boardstate_free(board: *mut BoardState);
    }

    extern "C" {
        #[doc = " Determines whether a player has won the game based on the number of"]
        #[doc = " squares controlled by each player. This function must be called"]
        #[doc = " while the current player for the board state is still set to the player"]
        #[doc = " who made the last move, not the player who will make the next move;"]
        #[doc = " note that this function does not replace playerHasValidMove: the game"]
        #[doc = " can end without the map being definitively divided"]
        #[doc = " @param board Board state to check"]
        #[doc = " @param white Where to store the number of squares controlled by white"]
        #[doc = " @param black Where to store the number of squares controlled by black"]
        #[doc = " @return The winning player, or EMPTY if neither player has won"]
        pub fn boardstate_winner(
            board: *mut BoardState,
            white: *mut ::std::os::raw::c_int,
            black: *mut ::std::os::raw::c_int,
        ) -> SquareState;
    }

    extern "C" {
        #[doc = " Determines the state of a given square on the board"]
        #[doc = " @param board Board state to check"]
        #[doc = " @param square Square to check"]
        #[doc = " @return The state of the given square"]
        pub fn boardstate_squareState(board: *mut BoardState, square: *mut Square) -> SquareState;
    }

    extern "C" {
        #[doc = " Determines who controls the region containing a given square on the board;"]
        #[doc = " the map should be updated before calling this function"]
        #[doc = " @param board Board state to check"]
        #[doc = " @param square Square to check"]
        #[doc = " @return The controller of the region containing the given square"]
        pub fn boardstate_squareController(
            board: *mut BoardState,
            square: *mut Square,
        ) -> SquareState;
    }

    extern "C" {
        #[doc = " Determines whether a player has any valid moves"]
        #[doc = " @param board Board state"]
        #[doc = " @param player The player to check"]
        #[doc = " @return Whether the specified player has any valid moves"]
        pub fn playerHasValidMove(
            board: *mut BoardState,
            player: SquareState,
        ) -> ::std::os::raw::c_int;
    }

    extern "C" {
        #[doc = " Determine whether a move is valid"]
        #[doc = " @param board Board state"]
        #[doc = " @param src Starting location"]
        #[doc = " @param dst Ending location"]
        #[doc = " @return Whether the specified squares are on the same row, column, or diagonal"]
        pub fn isValidMove(
            board: *mut BoardState,
            src: *mut Square,
            dst: *mut Square,
        ) -> ::std::os::raw::c_int;
    }

    extern "C" {
        #[doc = " Move an Amazon"]
        #[doc = " @param board Board state"]
        #[doc = " @param src Current location of the Amazon"]
        #[doc = " @param dst Destination location of the Amazon"]
        #[doc = " @return Whether the specified move is valid"]
        pub fn amazons_move(
            board: *mut BoardState,
            src: *mut Square,
            dst: *mut Square,
        ) -> ::std::os::raw::c_int;
    }

    extern "C" {
        #[doc = " Shoot an arrow"]
        #[doc = " @param board Board state"]
        #[doc = " @param src Current location of the firing Amazon"]
        #[doc = " @param target Target location of the firing Amazon"]
        #[doc = " @return Whether the specified shot is valid"]
        pub fn amazons_shoot(
            board: *mut BoardState,
            src: *mut Square,
            target: *mut Square,
        ) -> ::std::os::raw::c_int;
    }
}
